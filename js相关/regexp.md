# 正则表达式
## 1. 正则表达式的定义
正则表达式是由普通字符和特殊字符(也叫元字符或限定符)组成的文字模板， 如下便是简单的匹配连续数字的正则表达式:
```
/[0-9]+/
/\d+/
```
“\d” 就是元字符, 而 “+” 则是限定符.
### 1.1 元字符
---
| 元字符    |  描述 |
| :-------- |:--------:|
| .      | 匹配除换行符以外的任意字符 |  
| \d     |   匹配数字, 等价于字符组[0-9] |  
| \w     |   匹配字母, 数字, 下划线或汉字 | 
|\s	|匹配任意的空白符(包括制表符,空格,换行等)|
|\b|	匹配单词开始或结束的位置|
|^	|匹配行首|
|$	|匹配行尾|
### 1.2反义元字符
---
| 反义元字符    |  描述 |
| :-------- |:--------:|
|\D	|匹配非数字的任意字符, 等价于[^0-9]|
|\W	|匹配除字母,数字,下划线或汉字之外的任意字符|
|\S |匹配非空白的任意字符|
|\B |匹配非单词开始或结束的位置|
|[^x]|匹配除x以外的任意字符|

可以看出正则表达式严格区分大小写.
### 1.3重复限定符
---
限定符共有6个, 假设重复次数为x次, 那么将有如下规则:
| 限定符    |  描述 |
| :-------- |:--------:|
|*	|x>=0|
|+	|x>=1|
|?  |x=0 or x=1|
|{n}	|x=n|
|{n,}	|x>=n|
|{n,m}	|n<=x<=m|
### 1.4字符组
---
[…] 匹配中括号内字符之一. 如: [xyz] 匹配字符 x, y 或 z. 如果中括号中包含元字符, 则元字符降级为普通字符, 不再具有元字符的功能, 如 [+.?] 匹配 加号, 点号或问号.
### 1.5排除性字符组
---
[^…] 匹配任何未列出的字符,. 如: [^x] 匹配除x以外的任意字符.
### 1.6多选结构
---
| 就是或的意思, 表示两者中的一个. 如: a|b 匹配a或者b字符.
### 1.7括号
---
括号 常用来界定重复限定符的范围, 以及将字符`分组`. 如: (ab)+ 可以匹配abab..等, 其中 ab 便是一个分组.
### 1.8转义字符
---
\ 即转义字符, 通常 `\ * + ? | { [ ( ) ] }^ $ . #` 和` 空白 `这些字符都需要转义.
### 1.9操作符的运算优先级
---
1.\ 转义符
2.(), (?:), (?=), [] 圆括号或方括号
3.*, +, ?, {n}, {n,}, {n,m} 限定符
4.^, $ 位置
5.| “或” 操作
### 1.10测试
---
我们来测试下上面的知识点, 写一个匹配手机号码的正则表达式, 如下:
```
(\+86)?1\d{10}
```
① “\+86” 匹配文本 “+86”, 后面接元字符问号, 表示可匹配1次或0次, 合起来表示 “(\+86)?” 匹配 “+86” 或者 “”.
② 普通字符”1” 匹配文本 “1”.
③ 元字符 “\d” 匹配数字0到9, 区间量词 “{10}” 表示匹配 10 次, 合起来表示 “\d{10}” 匹配连续的10个数字.
## 2.修饰符
javaScript中正则表达式默认有如下五种修饰符:
* g (全文查找)
* i (忽略大小写查找)
* m (多行查找)
* y (ES6新增的粘连修饰符)
* u (ES6新增)

## 3.常用的正则表达式
1. 汉字: [\u4e00-\u9fa5]{0,}
1. Email: ^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
1. URL: ^https?://([\w-]+.)+[\w-]+(/[\w-./?%&=]*)?$
1. 手机号码: ^1\d{10}$
1. 身份证号: ^(\d{15}|\d{17}(\d|X))$
1. 中国邮政编码: [1-9]\d{5}(?!\d) (邮政编码为6位数字)

### 3.1密码验证
---
密码验证是常见的需求, 一般来说, 常规密码大致会满足规律: 6-16位, 数字, 字母, 字符至少包含两种, 同时不能包含中文和空格. 如下便是常规密码验证的正则描述:
```
var reg = /(?!^[0-9]+$)(?!^[A-z]+$)(?!^[^A-z0-9]+$)^[^\s\u4e00-\u9fa5]{6,16}$/;
```
## 4.正则的几大家族
### 4.1正则表达式分类
---
在 linux 和 osx 下, 常见的正则表达式, 至少有以下三种:
* 基本的正则表达式( Basic Regular Expression 又叫 Basic RegEx 简称 BREs )
* 扩展的正则表达式( Extended Regular Expression 又叫 Extended RegEx 简称 EREs )
* Perl 的正则表达式( Perl Regular Expression 又叫 Perl RegEx 简称 PREs )
### 4.2正则表达式比较
---

| 字符    |  说明 |Basic RegEx |	Extended RegEx|python RegEx|Perl regEx|
| :-------- |:--------:|:--------:|:--------:|:--------:|:--------:|
|转义	|				
|^	|匹配行首，例如’^dog’匹配以字符串dog开头的行（注意：awk 指令中，’^’则是匹配字符串的开始）|	^	|^	|^	|^|
|$	|匹配行尾，例如：’^、dog\$’ 匹配以字符串 dog 为结尾的行（注意：awk 指令中，’$’则是匹配字符串的结尾）|	$	|$	|$|	$|
|^$	|匹配空行	|^$	|^$	|^$	|^$|
|^string$	|匹配行，例如：’^dog$’匹配只含一个字符串 dog 的行	|^string$	|^string$	|^string$	|^string$|
|\<	|匹配单词，例如：’\<frog’ （等价于’\bfrog’），匹配以 frog 开头的单词	|\<	|\<	|不支持	|不支持（但可以使用\b来匹配单词，例如：’\bfrog’）|
|>|	匹配单词，例如：’frog>‘（等价于’frog\b ‘），匹配以 frog 结尾的单词|	>	|>|	不支持	|不支持（但可以使用\b来匹配单词，例如：’frog\b’）|
|\	|匹配一个单词或者一个特定字符，例如：’\‘（等价于’\bfrog\b’）、’\‘	|\ |\	|不支持	|不支持（但可以使用\b来匹配单词，例如：’\bfrog\b’|
|()	|匹配表达式，例如：不支持’（frog）’	|不支持（但可以使用，如：dog|	()	|()	|()|
||匹配表达式，例如：不支持’（frog）’|	|不支持（同())|	不支持（同())|	不支持（同())|
|？	|匹配前面的子表达式 0 次或 1 次（等价于{0,1}），例如：where(is)?能匹配”where” 以及”whereis”	|不支持（同\?)|	？	|？	|？|
|\?	|匹配前面的子表达式 0 次或 1 次（等价于’{0,1}‘），例如：’whereis\? ‘能匹配 “where”以及”whereis”|	\?|	不支持（同?)|	不支持（同?)|	不支持（同?)|
|?	|当该字符紧跟在任何一个其他限制符（*, +, ?, {n},{n,}, {n,m}） 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个”o”，而 ‘o+’ 将匹配所有 ‘o’|	不支持	|不支持	|不支持	|不支持|
|.	|匹配除换行符（’\n’）之外的任意单个字符（注意：awk 指令中的句点能匹配换行符）|	.	|.（如果要匹配包括“\n”在内的任何一个字符，请使用: [\s\S]|	.|	.（如果要匹配包括“\n”在内的任何一个字符，请使用：’ [.\n] ‘|
|*	|匹配前面的子表达式 0 次或多次（等价于{0, }），例如：zo* 能匹配 “z”以及 “zoo”	|*	| *|	*|	*|
|+	|匹配前面的子表达式 1 次或多次（等价于’{1, }‘），例如：’whereis+ ‘能匹配 “whereis”以及”whereisis”|	+	|不支持（同+)	|不支持（同+)|	不支持（同+)|
|+	|匹配前面的子表达式 1 次或多次（等价于{1, }），例如：zo+能匹配 “zo”以及 “zoo”，但不能匹配 “z”	|不支持（同\+)|	+|	+	|+|
|{n}|	n 必须是一个 0 或者正整数，匹配子表达式 n 次，例如：zo{2}能匹配	|不支持|（同\{n\})	|{n}|	{n}	|{n}|
|{n,}|	“zooz”，但不能匹配 “Bob”n 必须是一个 0 或者正整数，匹配子表达式大于等于 n次，例如：go{2,}	|不支持（同\{n,\})|	{n,} |	{n,}|	{n,}|
|{n,m}|	能匹配 “good”，但不能匹配 godm 和 n 均为非负整数，其中 n <= m，最少匹配 n 次且最多匹配 m 次 ，例如：o{1,3}将配”fooooood” 中的前三个 o（请注意在逗号和两个数之间不能有空格）	|不支持（同\{n,m\})	|{n,m}|	{n,m}|	{n,m}|
|x l y	|匹配 x 或 y	|不支持|（同x \l y	|x l y|	x l y|	x l y|
|[0-9]	|匹配从 0 到 9 中的任意一个数字字符（注意：要写成递增）	|[0-9]|	[0-9]|	[0-9]|	[0-9]|
|[xyz]	|字符集合，匹配所包含的任意一个字符，例如：’[abc]’可以匹配”lay” 中的 ‘a’（注意：如果元字符，例如：. *等，它们被放在[ ]中，那么它们将变成一个普通字符）|	[xyz]|	[xyz]	[xyz]|	[xyz]|
|[^xyz]	|负值字符集合，匹配未包含的任意一个字符（注意：不包括换行符），例如：’[^abc]’ 可以匹配 “Lay” 中的’L’（注意：[^xyz]在awk 指令中则是匹配未包含的任意一个字符+换行符）|	[^xyz] |	[^xyz]|	[^xyz]|	[^xyz]|
|[A-Za-z]	|匹配大写字母或者小写字母中的任意一个字符（注意：要写成递增）|	[A-Za-z]|	[A-Za-z]	|[A-Za-z]|	[A-Za-z]
|[^A-Za-z]	|匹配除了大写与小写字母之外的任意一个字符（注意：写成递增）|	[^A-Za-z]|	[^A-Za-z]	|[^A-Za-z]|	[^A-Za-z]
|\d|	匹配从 0 到 9 中的任意一个数字字符（等价于 [0-9]）|	不支持	|不支持	|\d	|\d
|\D|	匹配非数字字符（等价于 [^0-9]）	|不支持|	不支持	|\D	|\D|
|\S	|匹配任何非空白字符（等价于[^\f\n\r\t\v]）	|不支持	|不支持	|\S	|\S|
|\s	|匹配任何空白字符，包括空格、制表符、换页符等等（等价于[ \f\n\r\t\v]）	|不支持|	不支持	|\s	|\s|
|\W	|匹配任何非单词字符 (等价于[^A-Za-z0-9_])	|\W	|\W|	\W	|\W|
|\w	|匹配包括下划线的任何单词字符（等价于[A-Za-z0-9_]）	|\w|\w|	\w|	\w|
|\B	|匹配非单词边界，例如：’er\B’ 能匹配 “verb” 中的’er’，但不能匹配”never” 中的’er’|	\B|	\B|	\B|	\B
\b	|匹配一个单词边界，也就是指单词和空格间的位置，例如： ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的’er’|	\b	|\b	|\b	|\b|
|\t|	匹配一个横向制表符（等价于 \x09和 \cI）|	不支持	|不支持	|\t	|\t|
|\v	|匹配一个垂直制表符（等价于 \x0b和 \cK）	|不支持	|不支持	|\v	|\v|
|\n	|匹配一个换行符（等价于 \x0a 和\cJ）	|不支持	|不支持|	\n|	\n|
|\f|	匹配一个换页符（等价于\x0c 和\cL）	|不支持	|不支持	|\f	|\f|
|\r	|匹配一个回车符（等价于 \x0d 和\cM）|	不支持	|不支持|	\r|	\r|
|\	|匹配转义字符本身”\” | \  |   \	|  \ |	\|
|\cx	|匹配由 x 指明的控制字符，例如：\cM匹配一个Control-M 或回车符，x 的值必须为A-Z 或 a-z 之一，否则，将 c 视为一个原义的 ‘c’ 字符|	不支持	|不支持	||	\cx|
|\xn|	匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长，例如：’\x41’ 匹配 “A”。’\x041’ 则等价于’\x04’ & “1”。正则表达式中可以使用 ASCII 编码	|不支持	|不支持	|	|\xn|
|\num	|匹配 num，其中 num是一个正整数。表示对所获取的匹配的引用|	不支持|	\num|	\num|	|
|[:alnum:]|	匹配任何一个字母或数字（[A-Za-z0-9]），例如：’[[:alnum:]] ‘	|[:alnum:]|	[:alnum:]	|[:alnum:]	|[:alnum:]|
|[:alpha:]|	匹配任何一个字母（[A－Za－z]）， 例如：’ [[:alpha:]] ‘	|[:alpha:]	|[:alpha:]|	[:alpha:]|	[:alpha:]
|[:digit:]|	匹配任何一个数字（[0-9]），例如：’[[:digit:]] ‘	|[:digit:]	|[:digit:]|	[:digit:]|	[:digit:]|
|[:lower:]	|匹配任何一个小写字母（[a-z]）， 例如：’ [[:lower:]] ‘|	[:lower:]	|[:lower:]|	[:lower:]	|[:lower:]
|[:upper:]|	匹配任何一个大写字母（[A-Z]）|	[:upper:]|	[:upper:]|	[:upper:]|	[:upper:]|
|[:space:]|	任何一个空白字符： 支持制表符、空格，例如：’ [[:space:]] ‘	|[:space:]	|[:space:]|	[:space:]|	[:space:]|
|[:blank:]	|空格和制表符（横向和纵向），例如：’[[:blank:]]’ó’[\s\t\v]’	|[:blank:]|	[:blank:]|	[:blank:]|	[:blank:]|
|[:graph:]|	任何一个可以看得见的且可以打印的字符（注意：不包括空格和换行符等），例如：’[[:graph:]] ‘	|[:graph:]|	[:graph:]|[:graph:]	|[:graph:]|
|[:print:]	|任何一个可以打印的字符（注意：不包括：[:cntrl:]、字符串结束符’\0’、EOF 文件结束符（-1）， 但包括空格符号），例如：’[[:print:]] ‘	|[:print:]	|[:print:]|	[:print:]|	[:print:]|
|[:cntrl:]|	任何一个控制字符（ASCII 字符集中的前 32 个字符，即：用十进制表示为从 0 到31，例如：换行符、制表符等等），例如：’ [[:cntrl:]]’|	[:cntrl:]|	[:cntrl:]|	[:cntrl:]|	[:cntrl:]|
|[:punct:]	|任何一个标点符号（不包括：[:alnum:]、[:cntrl:]、[:space:]这些字符集）	|[:punct:]|	[:punct:]|	[:punct:]|	[:punct:]|
|[:xdigit:]|	任何一个十六进制数（即：0-9，a-f，A-F）	|[:xdigit:]	|[:xdigit:]|	[:xdigit:]|	[:xdigit:]|
注意
* js中支持的是EREs.
* 当使用 BREs ( 基本正则表达式 ) 时，必须在下列这些符号(?,+,|,{,},(,))前加上转义字符 \ .
* 上述[[:xxxx:]] 形式的正则表达式, 是php中内置的通用字符簇, js中并不支持.

## 5.正则表达式初阶技能
### 5.1贪婪模式与非贪婪模式
---
默认情况下, 所有的限定词都是贪婪模式, 表示尽可能多的去捕获字符; 而在限定词后增加?, 则是非贪婪模式, 表示尽可能少的去捕获字符. 如下:
```
var str = "aaab",
    reg1 = /a+/, //贪婪模式
    reg2 = /a+?/;//非贪婪模式
console.log(str.match(reg1)); //["aaa"], 由于是贪婪模式, 捕获了所有的a
console.log(str.match(regs)); //["a"], 由于是非贪婪模式, 只捕获到第一个a
```
实际上, 非贪婪模式非常有效, 特别是当匹配html标签时. 比如匹配一个配对出现的div, 方案一可能会匹配到很多的div标签对, 而方案二则只会匹配一个div标签对.
```
var str = "<div class='v1'><div class='v2'>test</div><input type='text'/></div>";
var reg1 = /<div.*<\/div>/; //方案一,贪婪匹配
var reg2 = /<div.*?<\/div>/;//方案二,非贪婪匹配
console.log(str.match(reg1));//"<div class='v1'><div class='v2'>test</div><input type='text'/></div>"
console.log(str.match(reg2));//"<div class='v1'><div class='v2'>test</div>"
```
#### 5.21区间量词的非贪婪模式
---
一般情况下, 非贪婪模式, 我们使用的是”*?”, 或 “+?” 这种形式, 还有一种是 “{n,m}?”.
区间量词”{n,m}” 也是匹配优先, 虽有匹配次数上限, 但是在到达上限之前, 它依然是尽可能多的匹配, 而”{n,m}?” 则表示在区间范围内, 尽可能少的匹配.
`需要注意的是:`
* 能达到同样匹配结果的贪婪与非贪婪模式, 通常是贪婪模式的匹配效率较高.
* 所有的非贪婪模式, 都可以通过修改量词修饰的子表达式, 转换为贪婪模式.
* 贪婪模式可以与`固化分组`(后面会讲到)结合，提升匹配效率，而非贪婪模式却不可以.

#### 5.2分组
---
正则的分组主要通过小括号来实现, 括号包裹的子表达式作为一个分组, 括号后可以紧跟限定词表示重复次数. 如下, 小括号内包裹的abc便是一个分组:
```
/(abc)+/.test("abc123") == true
```
